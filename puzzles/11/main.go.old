package main

import (
	"fmt"
	"math/big"
	"strconv"
	"strings"
	"time"

	"github.com/PhilAldridge/aoc-2024-go/pkg/files"
	"github.com/PhilAldridge/aoc-2024-go/pkg/ints"
)

func main() {
	start := time.Now()
	fmt.Println("Part 1: ", part1("input.txt"), " in:", time.Since(start))
	start = time.Now()
	fmt.Println("Part 2: ", part2("input.txt"), " in:", time.Since(start))
}

func part1(name string) int {
	bigStones := getStonesP2(name)
	return blinkPart2(25,bigStones)
}

func part2(name string) int {
	bigStones := getStonesP2(name)
	return blinkPart2(75,bigStones)
}

func getStones(name string) []big.Int {
	stones := ints.FromStringSlice(strings.Split(files.Read(name)," "))
	bigStones := []big.Int{}
	for _,stone:= range stones {
		bigStones = append(bigStones, *big.NewInt(int64(stone)))
	}
	return bigStones
}
func getStonesP2(name string) []uint64 {
	stones := ints.FromStringSlice(strings.Split(files.Read(name)," "))
	bigStones := []uint64{}
	for _,stone:= range stones {
		bigStones = append(bigStones, uint64(stone))
	}
	return bigStones
}

func blink(times int, bigStones []big.Int) []big.Int {
	zero:= big.NewInt(0)
	multVal := big.NewInt(2024)
	
	
	for i:=0; i<times; i++ {
		newBigStones:= []big.Int{}
		for _,stone:= range bigStones {
			stoneStr := stone.String()
			if stone.Cmp(zero) == 0 {
				newBigStones = append(newBigStones, *big.NewInt(1))
			} else if len(stoneStr) %2 ==0 {
				half:= len(stoneStr)/2
				left:= new(big.Int)
				right := new(big.Int)
				left.SetString(stoneStr[:half],10)
				right.SetString(stoneStr[half:],10)
				newBigStones = append(newBigStones, *left)
				newBigStones = append(newBigStones, *right)
			} else {
				newBigStones = append(newBigStones, *stone.Mul(&stone,multVal))
			}
		}
		bigStones = newBigStones
	}
	return bigStones
}

func blinkPart2(times int, stones []uint64) int {
	progression := make(map[uint64][]uint64)
	total:= 0
	for i, stone:= range stones {
		total += blink1Stone(times, stone, progression)
		fmt.Printf("%d total: %d\n",i,total)
	}
	return total
}

func blink1Stone(times int, stone uint64, progression map[uint64][]uint64) int {
	if times == 0 {
		return 1
	}
	v,ok:= progression[stone]
	newTotal:= 0
	if ok && len(v) >0 {
		for _,next:= range v {
			newTotal += blink1Stone(times-1,next,progression)
		}
		return newTotal
	}
	var nextStones []uint64
	stoneStr:= strconv.FormatUint(stone,10)
	if stone ==0 {
		nextStones = append(nextStones, 1)
	} else if len(stoneStr)%2 ==0 {
		left,_ := strconv.ParseUint(stoneStr[:len(stoneStr)/2],10,64)
		right,_ := strconv.ParseUint(stoneStr[len(stoneStr)/2:],10,64)
		nextStones = append(nextStones,left )
		nextStones = append(nextStones, right)
	} else {
		nextStones = append(nextStones, stone*2024)
	}
	progression[stone] = nextStones
	for _,next:= range nextStones {
		newTotal += blink1Stone(times-1,next,progression)
	}
	fmt.Println(stone)
	fmt.Println(progression[stone])
	return newTotal
}
